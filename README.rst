
This is a corpus of standalone test cases which are known to produce crashes,
or miscompiles when run with a recent snapshot of LLVM.  (See details on supported failure types below.)

To contribute a test to be auto-triaged, please post a pull request. Once
accepted, the automated reducer should have added reduced examples within
roughly 24 hours.

The primary purpose of this repo is to act as an example and test corpus
for my (as yet unpublished) automated corpus management project. Because of
this, YOU SHOULD NOT EXPECT THE HISTORY OF THIS REPO TO BE STABLE.  Force
pushes to this repository to remove history may be common (e.g. removing
large files entirely from history, etc..).


Test Format
-----------

Each test must be a self describing LIT test.  The intention is that the
test file could be copied into the LLVM test sub-directory and work as
expected. As such, each test should include a header which looks like this:

.. code::

  ; RUN: opt -S -passname < %s
  ; REQUIRES: asserts
  ; XFAIL:

The binary exercised must be either a) an LLVM tool (e.g opt, llc,
or clang), or an alive2 tool (eg. opt-alive.sh, alive-tv).  If using
an alive2 too, the REQUIRES line must list "alive".

Each test is required to run in less than 5 minutes.  Tests that exceed
this on any test platform will be deleted.

Current implementation restrictions:

* Only the RUN line is parsed and used by the corpus automation, but all
  comment lines will be preserved during reduction.  You can also use
  comments (e.g. lines starting with ";" to give description of the test
  if desired.
* The current parsing of RUN is rather adhoc, so sticking exactly to this
  example's format is highly recommended.
* At the moment, all tests are assumed to require asserts.

Layout
------

All original tests should be under a named sub-directory.  As an example,
a reproducer taken from OSSFuzz should be placed under the oss_fuzz subdir.
Naming withing these sub-directory is unconstrained.

All other tests (e.g. results from automated reduction efforts) must be in
the root directory with names which correspond to the sha1 hash of the file
contents.

Long term, the use of named sub-directories will probably be removed
entirely and replaced with a metadata file, but for the moment having the
separation is useful for testing as it makes it easy to delete only the
autogenerated files.

Supported Failure Types
-----------------------

The automated reducer can currently reduce the following types of failures:

* Crashes and assertion failures on IR inputs.  LLVM is compiled with
  assertions enabled. If the input IR triggers a crash in an llvm tool, this
  can be reduced.
* Miscompiles confirmed by alive on IR inputs.  If alive is capable of
  reporting a miscompile with the example test, we can reduce the IR to the
  minimum which produces the miscompile.

The automated reducer will reduce *any* failure seen in the test case.  Since
reducers are simply a sub-case of mutation fuzzers, this means that sometimes
the attempted reduction can introduce a new failure cause.  This means that
the reduced test case may fail for a different reason that the original test.

The following failure types can not (yet?) be reduced:

* Any non-IR input.  In particular, this means that reducing clang crashes
  or miscompiles is not yet supported.  Similiarly, MIR is not yet supported.
  Similiarly, tools such as llvm-objdump with non-IR inputs are not yet
  supported.
* Sanitizer failures.  The LLVM build exercised does not enable ubsan, asan,
  msan, or tsan.
* Non deterministic failures.  A test which only fails some of the time
  will probably not be successfully reduced.
* Infinite compilations.  Tests which exceed the timeout are discarded, and
  will not be reduced.
* Excess memory usage.  Tests which consume large amounts of memory are
  discarded and will not be reduced.
* Execution failures.  The automation will not run binaries produced from
  user test cases.  As a result, miscompiles resulting in execution failures
  - which can not also be found by alive - can not be reduced.

Supported Reducers
------------------

Currently, the following reducers are supported:

* bugpoint (specifically, its crash reduction mode).  Bugpoint will be used
  to reduce crashes in opt with IR inputs.  Currently crash reduction is
  unconstrained meaning that *any* crash will be reduced.
* llvm-reduce.  llvm-reduce will be used to reduce crashes in LLVM tools, and
  miscompiles reported by alive on IR inputs.  Currently, reduction is
  unconstrained meaning that any failure will be reduced.
* opt-analysis-isolate.  This is a custom reducer which attempts to reproduce
  opt crashes with only analysis printers (i.e. no transformation passes).
  When successful, this makes it clear when a problem exists in an analysis
  as opposed to (possibly many) consumer passes.

The results from reducers will be cross fed - i.e. a reduced output from
bugpoint will be further reduced via llvm-reduce and vice-versa.  Note that
it is common to have reductions converge to multiple different maximally
reduced IRs.  That is, the reduction result is often path dependent on the
reduction order chosen.  It can be insightful to compare them.

In the nearish future, the following additions are planned:

* creduce to reduce c/c++ language inputs for clang crashes.
* clang to opt runline conversion.  Many times we can derive a crashing opt
  test by taking clang's -emit-llvm output and doing a bit of cleanup.
* Constrained reduction of assertion failures.





